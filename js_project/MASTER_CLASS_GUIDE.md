# Мастер-класс: Подготовка к экзамену по ООП

## Полный текст выступления

---

## Введение

Здравствуйте! Сегодня мы будем готовиться к экзамену по объектно-ориентированному программированию на примере реального проекта. Я покажу вам, как все принципы ООП работают на практике, объясню код построчно и расскажу, на что обратить внимание при подготовке к экзамену.

Наш проект - это система управления начислениями за коммунальные услуги. Он написан на JavaScript, но все принципы, которые мы изучим, применимы к любому объектно-ориентированному языку.

---

## Часть 1: Знакомство с проектом

### Что делает наш проект?

Давайте сначала разберемся, зачем нужен этот проект. Представьте себе управляющую компанию, которая должна:

1. Хранить информацию о жителях, их лицевых счетах и адресах
2. Ведет учет услуг: вода, электричество, отопление, газ
3. Рассчитывает начисления за эти услуги
4. Генерирует красивые извещения на оплату в формате Excel

Именно это и делает наша система. Она не просто хранит данные - она использует объектно-ориентированный подход, где каждый элемент системы представлен в виде класса.

### Зачем этот проект для изучения ООП?

Этот проект - идеальный пример для изучения ООП, потому что он демонстрирует ВСЕ четыре основных принципа:

1. **Инкапсуляция** - мы скрываем внутреннюю реализацию классов
2. **Наследование** - создаем иерархии классов
3. **Полиморфизм** - разные классы реализуют один интерфейс по-разному
4. **Абстракция** - выделяем общие характеристики объектов

И главное - все это в одном проекте, который можно запустить и посмотреть, как он работает.

---

## Часть 2: Структура проекта

Давайте посмотрим на структуру проекта. Откройте папку с проектом - вы увидите несколько файлов. Каждый файл отвечает за свою часть системы.

### Файл models.js - Модели данных

Этот файл содержит базовые классы - "кирпичики" нашей системы:

- **Street** (Улица) - простой класс, хранит код улицы и название
- **PersonalAccount** (Лицевой счет) - хранит информацию о счете: номер, адрес, ФИО владельца
- **Service** (Услуга) - описывает коммунальную услугу: код, название, тариф
- **Charge** (Начисление) - представляет одно начисление за услугу
- **PaymentNotice** (Извещение на оплату) - объединяет всю информацию для генерации документа

**Почему это важно для ООП?** Здесь мы видим, как реальные сущности превращаются в классы. Каждый класс - это описание объекта из реального мира.

### Файл database.js - Работа с данными

Класс `Database` - это место, где хранятся все данные. Он использует инкапсуляцию: данные скрыты внутри класса, доступ к ним возможен только через публичные методы.

**Принцип ООП:** Инкапсуляция. Внутренняя структура (как хранятся данные) скрыта от внешнего кода.

### Файл chainOfResponsibility.js - Обработка начислений

Здесь реализован паттерн проектирования "Chain of Responsibility" (цепочка ответственности). Это яркий пример наследования и полиморфизма:

- **ChargeHandler** - базовый класс-обработчик
- **ValidationChargeHandler** - проверяет данные (наследуется от ChargeHandler)
- **DiscountChargeHandler** - применяет скидки (наследуется от ChargeHandler)
- **StandardChargeHandler** - выполняет стандартный расчет (наследуется от ChargeHandler)
- **ChargeProcessor** - координирует работу всех обработчиков

**Принципы ООП:** Наследование, полиморфизм, абстракция - все сразу!

### Файл excelGenerator.js - Генерация документов

Класс `ExcelGenerator` создает красивые Excel-файлы с извещениями. Он демонстрирует композицию - использует другие классы для своей работы.

**Принцип ООП:** Композиция (форма инкапсуляции).

### Файл dateTimeUtils.js - Работа с датами

Класс `DateTimeHandler` - это утилитарный класс со статическими методами. Демонстрирует, что не всегда нужно создавать объекты - иногда достаточно статических методов.

### Файл main.js - Точка входа

Главный файл программы. Здесь создаются объекты, вызываются методы, запускается вся система. Это пример того, как использовать созданные классы.

---

## Часть 3: Принципы ООП в проекте

Теперь давайте детально разберем каждый принцип ООП и посмотрим, где и как он используется в нашем проекте.

---

### Принцип 1: ИНКАПСУЛЯЦИЯ

**Что это такое?**

Инкапсуляция - это объединение данных (свойств) и методов (функций) в одном объекте и скрытие внутренней реализации от внешнего кода. Простыми словами: "данные и функции, работающие с этими данными, находятся вместе, и мы контролируем, как с ними можно работать".

#### Где используется в проекте?

##### Пример 1: Приватные поля в классе Database

Откройте файл `database.js`. Посмотрите на класс `Database`:

```javascript
export class Database {
  // Приватные поля - недоступны извне
  #streets = new Map();
  #accounts = new Map();
  #services = new Map();
  #charges = new Map();

  constructor() {
    // Приватные поля уже инициализированы
  }

  addStreet(street) {
    this.#streets.set(street.streetCode, street);
  }

  getStreet(streetCode) {
    return this.#streets.get(streetCode);
  }
}
```

**Что здесь происходит?**

- Символ `#` перед именем поля означает, что это приватное поле
- Поля `#streets`, `#accounts` и другие НЕ доступны напрямую извне класса
- Доступ к ним возможен ТОЛЬКО через публичные методы: `addStreet()`, `getStreet()`

**Почему это важно?**

Попробуйте в коде написать `db.#streets` - вы получите ошибку! Это и есть инкапсуляция: мы защищаем данные от случайного изменения. Если нужно добавить улицу, используется метод `addStreet()`, который может проверить данные, выполнить дополнительную логику и т.д.

**Вопрос для экзамена:** "Что такое инкапсуляция? Приведите пример из проекта."

**Ответ:** Инкапсуляция - это объединение данных и методов в одном объекте и скрытие внутренней реализации. В проекте класс `Database` использует приватные поля `#streets`, `#accounts` (недоступные извне) и предоставляет публичные методы для работы с ними.

##### Пример 2: Методы класса Service

Откройте `models.js`, класс `Service`:

```javascript
export class Service {
  constructor(serviceCode, name, tariff) {
    this.serviceCode = serviceCode;
    this.name = name;
    this.tariff = tariff; // Данные объекта
  }

  calculateCost(quantity) {
    // Метод работает с данными объекта
    return this.tariff * quantity;
  }
}
```

**Что здесь происходит?**

- Данные (`tariff`) и метод (`calculateCost`) объединены в одном классе
- Метод `calculateCost()` использует данные объекта через `this.tariff`
- Логика расчета стоимости инкапсулирована внутри класса

**Почему это инкапсуляция?**

Мы не просто умножаем тариф на количество где-то в коде. Логика расчета находится внутри класса `Service`, рядом с данными. Если понадобится изменить способ расчета (например, добавить налог), мы изменим только один метод, а не весь код программы.

---

### Принцип 2: НАСЛЕДОВАНИЕ

**Что это такое?**

Наследование - это создание нового класса на основе существующего класса. Новый класс (дочерний) наследует все свойства и методы родительского класса и может их расширять или переопределять.

Простыми словами: "Я хочу создать новый класс, похожий на существующий, но с некоторыми отличиями".

#### Где используется в проекте?

##### Пример: Иерархия обработчиков начислений

Откройте файл `chainOfResponsibility.js`. Здесь целая иерархия классов!

**Базовый класс ChargeHandler:**

```javascript
export class ChargeHandler {
  #nextHandler = null;

  constructor() {
    // Конструктор может быть пустым
  }

  setNext(handler) {
    this.#nextHandler = handler;
    return handler; // Возвращает для цепочки вызовов
  }

  handle(charge, service) {
    throw new Error("Метод должен быть переопределен в дочернем классе");
  }

  #processNext(charge, service) {
    if (this.#nextHandler) {
      return this.#nextHandler.handle(charge, service);
    }
    return null;
  }

  _processNext(charge, service) {
    return this.#processNext(charge, service);
  }
}
```

**Дочерний класс ValidationChargeHandler:**

```javascript
export class ValidationChargeHandler extends ChargeHandler {
  // Наследует все методы из ChargeHandler
  // Переопределяет метод handle()

  handle(charge, service) {
    if (charge.quantity < 0) {
      throw new Error(
        `Отрицательное количество для начисления #${charge.chargeCode}`
      );
    }
    if (service.tariff < 0) {
      throw new Error(`Отрицательный тариф для услуги #${service.serviceCode}`);
    }
    // Использует метод родителя через this._processNext()
    return this._processNext(charge, service);
  }
}
```

**Что здесь происходит?**

- `extends ChargeHandler` - ключевое слово `extends` означает наследование
- `ValidationChargeHandler` автоматически получает методы `setNext()` и `_processNext()` из родительского класса
- Метод `handle()` переопределяется - у дочернего класса своя реализация

**Другие дочерние классы:**

```javascript
// Обработчик скидок
export class DiscountChargeHandler extends ChargeHandler {
  constructor(discountThreshold, discountPercent) {
    super(); // Вызов конструктора родителя
    this.discountThreshold = discountThreshold;
    this.discountPercent = discountPercent;
  }

  handle(charge, service) {
    const baseCost = service.calculateCost(charge.quantity);
    if (baseCost >= this.discountThreshold) {
      const discount = baseCost * (this.discountPercent / 100);
      return baseCost - discount;
    }
    return this._processNext(charge, service);
  }
}

// Стандартный обработчик
export class StandardChargeHandler extends ChargeHandler {
  handle(charge, service) {
    // Всегда вычисляет стандартную стоимость
    return service.calculateCost(charge.quantity);
  }
}
```

**Почему это наследование?**

Все три класса (`ValidationChargeHandler`, `DiscountChargeHandler`, `StandardChargeHandler`) имеют общую функциональность (метод `setNext()`, работа с цепочкой), но реализуют обработку по-разному. Вместо того, чтобы копировать код, мы выносим общее в базовый класс, а различия реализуем в дочерних.

**Вопрос для экзамена:** "Что такое наследование? Покажите пример из проекта."

**Ответ:** Наследование - это создание нового класса на основе существующего. В проекте класс `ValidationChargeHandler extends ChargeHandler` наследует методы базового класса и может их переопределять или дополнять. Ключевое слово `extends` означает "расширяет" или "наследуется от".

**Зачем нужно наследование?**

- Избегаем дублирования кода (общие методы в базовом классе)
- Легко добавлять новые типы обработчиков
- Обеспечиваем единый интерфейс для всех обработчиков

---

### Принцип 3: ПОЛИМОРФИЗМ

**Что это такое?**

Полиморфизм - это способность объектов разных классов отвечать на один и тот же метод по-разному. Простыми словами: "Один интерфейс, много реализаций".

#### Где используется в проекте?

##### Пример: Разные реализации метода handle()

Все три обработчика имеют метод `handle(charge, service)`, но каждый реализует его по-своему:

```javascript
// Обработчик 1: валидация
export class ValidationChargeHandler extends ChargeHandler {
  handle(charge, service) {
    // Реализация 1: проверяет данные
    if (charge.quantity < 0) throw new Error("...");
    return this._processNext(charge, service);
  }
}

// Обработчик 2: применение скидки
export class DiscountChargeHandler extends ChargeHandler {
  handle(charge, service) {
    // Реализация 2: применяет скидку
    const cost = service.calculateCost(charge.quantity);
    if (cost >= this.discountThreshold) {
      return cost - discount;
    }
    return this._processNext(charge, service);
  }
}

// Обработчик 3: стандартный расчет
export class StandardChargeHandler extends ChargeHandler {
  handle(charge, service) {
    // Реализация 3: просто вычисляет стоимость
    return service.calculateCost(charge.quantity);
  }
}
```

**Полиморфизм в действии:**

Посмотрите на класс `ChargeProcessor`:

```javascript
export class ChargeProcessor {
  #handler;

  constructor() {
    const validation = new ValidationChargeHandler();
    const discount = new DiscountChargeHandler(5000.0, 5.0);
    const standard = new StandardChargeHandler();

    validation.setNext(discount).setNext(standard);
    this.#handler = validation; // Сохраняем первый обработчик
  }

  processCharge(charge, service) {
    // Вызываем handle(), не зная точно, какой обработчик сработает
    const result = this.#handler.handle(charge, service);
    if (result === null) {
      throw new Error(`Не удалось обработать начисление`);
    }
    return result;
  }
}
```

**Что здесь происходит?**

- Метод `processCharge()` вызывает `this.#handler.handle()`
- Он НЕ знает, какой именно обработчик обработает запрос (валидация? скидка? стандартный?)
- Но это не важно! Все обработчики имеют метод `handle()` с одинаковой сигнатурой
- Каждый обработчик реализует его по-своему - это и есть полиморфизм

**Почему это важно?**

Мы можем легко добавлять новые обработчики, не изменяя код `ChargeProcessor`. Главное - чтобы новый обработчик имел метод `handle()` с правильной сигнатурой.

**Вопрос для экзамена:** "Что такое полиморфизм? Приведите пример."

**Ответ:** Полиморфизм - это способность объектов разных классов отвечать на один и тот же метод по-разному. В проекте три обработчика (`ValidationChargeHandler`, `DiscountChargeHandler`, `StandardChargeHandler`) все реализуют метод `handle()`, но каждый выполняет свою логику. Класс `ChargeProcessor` вызывает `handle()`, не зная точно, какой обработчик сработает, но зная, что все они имеют этот метод.

**Преимущества полиморфизма:**

- Можно работать с разными объектами через единый интерфейс
- Легко добавлять новые типы обработчиков
- Код становится более гибким и расширяемым

---

### Принцип 4: АБСТРАКЦИЯ

**Что это такое?**

Абстракция - это выделение общих характеристик объектов и создание абстрактных описаний, которые определяют ЧТО должно быть, но не КАК это реализовано.

Простыми словами: "Мы знаем, что объект должен уметь делать, но не важно, как именно он это делает".

#### Где используется в проекте?

##### Пример: Абстрактный метод в ChargeHandler

В базовом классе `ChargeHandler` есть метод `handle()`, который выбрасывает ошибку:

```javascript
export class ChargeHandler {
  handle(charge, service) {
    // Абстрактный метод: мы знаем ЧТО он должен делать,
    // но не знаем КАК (реализация в дочерних классах)
    throw new Error("Метод должен быть переопределен в дочернем классе");
  }
}
```

**Что здесь происходит?**

- Базовый класс определяет: "У каждого обработчика должен быть метод `handle()`"
- Но НЕ определяет, как именно этот метод должен работать
- Конкретная реализация делегируется дочерним классам

**Конкретные реализации:**

```javascript
// Конкретная реализация 1
class ValidationChargeHandler extends ChargeHandler {
  handle(charge, service) {
    // Конкретная реализация: проверка данных
    if (charge.quantity < 0) throw new Error("...");
    return this._processNext(charge, service);
  }
}

// Конкретная реализация 2
class DiscountChargeHandler extends ChargeHandler {
  handle(charge, service) {
    // Конкретная реализация: применение скидки
    // ...
  }
}
```

**Почему это абстракция?**

Мы абстрагируемся от деталей реализации. Когда мы работаем с объектом типа `ChargeHandler`, мы знаем, что у него есть метод `handle()`, но нам не важно, как именно он реализован. Это позволяет работать с разными обработчиками единообразно.

**Вопрос для экзамена:** "Что такое абстракция в ООП?"

**Ответ:** Абстракция - это выделение общих характеристик объектов и создание абстрактных описаний. В проекте класс `ChargeHandler` абстрактно определяет, что обработчик должен иметь метод `handle()`, но конкретную реализацию оставляет дочерним классам. Мы знаем ЧТО должен делать метод, но не знаем КАК это будет сделано в конкретных классах.

**Ключевые моменты:**

- Абстракция скрывает детали реализации
- Позволяет работать на более высоком уровне
- Упрощает понимание и использование системы

---

## Часть 4: Построчный разбор ключевого кода

Теперь давайте разберем код построчно, чтобы понять, как все работает на практике.

### Пример 1: Простой класс Street

Откройте `models.js`, класс `Street`:

```javascript
/**
 * Класс Улица.
 * Демонстрирует простой класс с инкапсуляцией данных.
 * Это пример КЛАССА как шаблона для создания объектов.
 */
export class Street {
  /**
   * Конструктор класса - специальный метод, вызываемый при создании объекта.
   * @param {number} streetCode - Код улицы
   * @param {string} name - Название улицы
   */
  constructor(streetCode, name) {
    // this - ссылка на текущий объект
    this.streetCode = streetCode; // Публичное свойство (публичное поле)
    this.name = name;
  }
}
```

**Построчное объяснение:**

**Строка 1: `export class Street {`**

- `export` - делает класс доступным для импорта в других файлах
- `class` - ключевое слово для объявления класса
- `Street` - имя класса (по соглашению - с заглавной буквы)
- `{` - начало тела класса

**Строка 2-6: Конструктор**

- `constructor(streetCode, name) {` - конструктор, вызываемый при создании объекта
- `streetCode, name` - параметры конструктора
- Эти параметры передаются при создании: `new Street(1, "Ленина")`

**Строка 7-8: Инициализация свойств**

- `this.streetCode = streetCode;` - создает свойство объекта
- `this` - ссылка на создаваемый объект
- После выполнения объект будет иметь свойство `streetCode`

**Как это работает:**

```javascript
// Создание объекта (экземпляра класса)
const street = new Street(1, "Ленина");
// 1. Выполняется constructor(1, "Ленина")
// 2. this = новый пустой объект {}
// 3. this.streetCode = 1
// 4. this.name = "Ленина"
// 5. Возвращается объект: { streetCode: 1, name: "Ленина" }

// Доступ к свойствам
console.log(street.streetCode); // 1
console.log(street.name); // "Ленина"
```

### Пример 2: Класс с методом - Service

```javascript
export class Service {
  constructor(serviceCode, name, tariff) {
    this.serviceCode = serviceCode;
    this.name = name;
    this.tariff = tariff;
  }

  calculateCost(quantity) {
    return this.tariff * quantity;
  }
}
```

**Построчное объяснение:**

**Строки 1-5: Конструктор**

- Аналогично классу `Street`, но с тремя параметрами
- Инициализирует три свойства объекта

**Строки 7-9: Метод класса**

- `calculateCost(quantity) {` - это МЕТОД класса (функция, принадлежащая объекту)
- `quantity` - параметр метода
- Метод можно вызвать только у объекта: `service.calculateCost(10)`

**Строка 8: `return this.tariff * quantity;`**

- `this.tariff` - обращение к свойству объекта
- Выполняет вычисление и возвращает результат
- Демонстрирует инкапсуляцию: метод работает с данными объекта

**Как это работает:**

```javascript
// Создание объекта
const service = new Service(1, "Холодное водоснабжение", 45.5);
// service = { serviceCode: 1, name: "Холодное водоснабжение", tariff: 45.5 }

// Вызов метода
const cost = service.calculateCost(10);
// Внутри метода: this = service
// this.tariff = 45.5
// return 45.5 * 10 = 455.0
// cost = 455.0
```

### Пример 3: Приватные поля в Database

```javascript
export class Database {
  // Приватные поля - демонстрация инкапсуляции
  #streets = new Map();
  #accounts = new Map();
  #services = new Map();
  #charges = new Map();

  constructor() {
    // Приватные поля уже инициализированы
  }

  addStreet(street) {
    this.#streets.set(street.streetCode, street);
  }

  getStreet(streetCode) {
    return this.#streets.get(streetCode);
  }
}
```

**Построчное объяснение:**

**Строка 3: `#streets = new Map();`**

- `#` - обозначает приватное поле (private field в JavaScript)
- `new Map()` - создает коллекцию типа Map (хранит пары ключ-значение)
- Это поле НЕ доступно извне класса
- Можно использовать только внутри методов класса

**Строка 6: `constructor() { }`**

- Пустой конструктор (приватные поля уже инициализированы при объявлении)

**Строки 9-11: Публичный метод `addStreet()`**

- Публичный метод для добавления улицы
- Это единственный способ добавить улицу (инкапсуляция)

**Строка 10: `this.#streets.set(street.streetCode, street);`**

- `this.#streets` - обращение к приватному полю внутри метода
- `.set(key, value)` - метод Map для сохранения пары ключ-значение
- `street.streetCode` - ключ (код улицы)
- `street` - значение (объект улицы)

**Как это работает:**

```javascript
const db = new Database();
const street = new Street(1, "Ленина");

// ✅ Правильно: через публичный метод
db.addStreet(street);

// ❌ Ошибка: нельзя обратиться к приватному полю
// db.#streets  // SyntaxError: Private field '#streets' must be declared

// ✅ Правильно: через публичный метод
const found = db.getStreet(1);
```

**Почему это важно для экзамена?**

- Показывает понимание инкапсуляции
- Демонстрирует использование приватных полей
- Защита данных от прямого доступа

### Пример 4: Наследование - ValidationChargeHandler

```javascript
export class ValidationChargeHandler extends ChargeHandler {
  handle(charge, service) {
    if (charge.quantity < 0) {
      throw new Error(
        `Отрицательное количество для начисления #${charge.chargeCode}`
      );
    }
    if (service.tariff < 0) {
      throw new Error(`Отрицательный тариф для услуги #${service.serviceCode}`);
    }
    return this._processNext(charge, service);
  }
}
```

**Построчное объяснение:**

**Строка 1: `extends ChargeHandler`**

- Ключевое слово `extends` означает наследование
- `ValidationChargeHandler` наследует все методы и свойства `ChargeHandler`
- Может использовать методы родителя через `this._processNext()`

**Строка 2: `handle(charge, service) {`**

- ПЕРЕОПРЕДЕЛЕНИЕ метода из родительского класса
- Та же сигнатура (имя и параметры), но другая реализация
- Это ПОЛИМОРФИЗМ: один интерфейс, разная реализация

**Строки 3-6: Валидация данных**

- Проверяет, что количество не отрицательное
- Если условие не выполняется, выбрасывает ошибку
- Обработка прерывается

**Строка 10: `return this._processNext(charge, service);`**

- Если валидация прошла, передает обработку следующему обработчику
- `this._processNext()` - метод из родительского класса
- Цепочка обработки продолжается

**Как это работает в цепочке:**

```javascript
// Создание обработчиков
const validation = new ValidationChargeHandler();
const discount = new DiscountChargeHandler(5000, 5);
const standard = new StandardChargeHandler();

// Создание цепочки
validation.setNext(discount).setNext(standard);
// validation -> discount -> standard

// Обработка
const charge = new Charge(1, 1, 1, 10);
const service = new Service(1, "Услуга", 100);

validation.handle(charge, service);
// 1. ValidationChargeHandler.handle() - проверяет данные
// 2. Если ОК, вызывает discount.handle() (через _processNext)
// 3. DiscountChargeHandler.handle() - применяет скидку или передает дальше
// 4. StandardChargeHandler.handle() - вычисляет стоимость
```

### Пример 5: Композиция - ChargeProcessor

```javascript
export class ChargeProcessor {
  #handler;

  constructor() {
    const validation = new ValidationChargeHandler();
    const discount = new DiscountChargeHandler(5000.0, 5.0);
    const standard = new StandardChargeHandler();

    validation.setNext(discount).setNext(standard);
    this.#handler = validation;
  }

  processCharge(charge, service) {
    const result = this.#handler.handle(charge, service);
    if (result === null) {
      throw new Error(`Не удалось обработать начисление`);
    }
    return result;
  }
}
```

**Построчное объяснение:**

**Строка 2: `#handler;`**

- Приватное поле для хранения первого обработчика в цепочке

**Строка 4: `constructor() {`**

- В конструкторе создаются и настраиваются обработчики
- Демонстрирует КОМПОЗИЦИЮ: класс содержит другие объекты

**Строка 5: `const validation = new ValidationChargeHandler();`**

- Создание объекта (экземпляра класса)
- `new` - оператор создания объекта
- Вызывает конструктор класса

**Строка 9: `validation.setNext(discount).setNext(standard);`**

- Цепочка вызовов (Fluent Interface)
- `validation.setNext(discount)` возвращает `discount`
- Затем `discount.setNext(standard)` устанавливает следующий
- Результат: validation -> discount -> standard

**Строка 10: `this.#handler = validation;`**

- Сохраняет первый обработчик как точку входа в цепочку

**Строка 13: `processCharge(charge, service) {`**

- Публичный метод для обработки начисления
- Делегирует работу объекту `#handler`

**Строка 14: `const result = this.#handler.handle(charge, service);`**

- Вызывает метод `handle()` первого обработчика
- Запускается цепочка обработчиков
- Полиморфизм: не важно, какой именно обработчик, главное - есть метод `handle()`

**Почему это важно?**

- Демонстрирует КОМПОЗИЦИЮ (Composition over Inheritance)
- Показывает делегирование
- Упрощает использование: не нужно знать детали цепочки

---

## Часть 5: Как использовать проект для подготовки к экзамену

### Стратегия подготовки

1. **Изучите структуру проекта**

   - Какие классы есть и за что они отвечают
   - Как классы связаны между собой
   - Какие паттерны проектирования используются

2. **Разберите каждый класс**

   - Конструктор: что он делает и какие параметры принимает
   - Свойства (поля): какие данные хранят объекты
   - Методы: какие действия могут выполнять объекты

3. **Найдите примеры ООП принципов**

   - Где используется инкапсуляция? (приватные поля `#`)
   - Где демонстрируется наследование? (`extends`)
   - Как проявляется полиморфизм? (разные реализации `handle()`)
   - Где применена абстракция? (абстрактный метод в `ChargeHandler`)

4. **Запустите проект**

   - Выполните `npm install` и `npm start`
   - Посмотрите, как работает система
   - Изучите сгенерированные Excel-файлы

5. **Попробуйте модифицировать проект**
   - Добавьте новый класс
   - Создайте новый обработчик наследуясь от `ChargeHandler`
   - Добавьте новый метод в существующий класс

---

## Часть 6: Типичные вопросы экзамена

### Вопрос 1: "Что такое класс в ООП?"

**Ответ:**
Класс - это шаблон (чертеж) для создания объектов. Класс определяет:

- Какие свойства будут у объектов (поля)
- Какие действия могут выполнять объекты (методы)

**Пример из проекта:**

```javascript
class Street {
  constructor(streetCode, name) {
    this.streetCode = streetCode; // Свойство
    this.name = name; // Свойство
  }
}

// Использование класса для создания объектов
const street1 = new Street(1, "Ленина");
const street2 = new Street(2, "Пушкина");
```

**Ключевые моменты:**

- Класс - это определение, объект - это конкретный экземпляр
- `new` - оператор создания объекта
- Один класс может создавать множество объектов

### Вопрос 2: "Что такое конструктор класса?"

**Ответ:**
Конструктор - это специальный метод класса, который вызывается при создании объекта через `new`. Конструктор используется для инициализации объекта (установки начальных значений свойств).

**Пример из проекта:**

```javascript
class Service {
  constructor(serviceCode, name, tariff) {
    // Инициализация свойств объекта
    this.serviceCode = serviceCode;
    this.name = name;
    this.tariff = tariff;
  }
}

// При создании объекта автоматически вызывается constructor
const service = new Service(1, "Вода", 45.5);
// Внутри: constructor(1, "Вода", 45.5)
// this.serviceCode = 1
// this.name = "Вода"
// this.tariff = 45.5
```

### Вопрос 3: "Объясните принцип инкапсуляции"

**Ответ:**
Инкапсуляция - это объединение данных и методов в одном объекте и скрытие внутренней реализации от внешнего кода.

**Примеры:**

1. **Приватные поля:**

```javascript
class Database {
  #streets = new Map(); // Приватное поле - недоступно извне

  addStreet(street) {
    // Публичный метод - единственный способ доступа
    this.#streets.set(street.streetCode, street);
  }
}

const db = new Database();
db.addStreet(street); // ✅ Работает
db.#streets; // ❌ Ошибка: приватное поле недоступно
```

2. **Методы класса:**

```javascript
class Service {
  constructor(serviceCode, name, tariff) {
    this.tariff = tariff; // Данные
  }

  calculateCost(quantity) {
    // Метод работает с данными
    return this.tariff * quantity;
  }
}

// Логика расчета инкапсулирована внутри класса
const cost = service.calculateCost(10);
```

**Преимущества:**

- Защита данных от неправильного использования
- Упрощение изменения внутренней реализации
- Улучшение читаемости кода

### Вопрос 4: "Что такое наследование? Покажите пример"

**Ответ:**
Наследование - это создание нового класса на основе существующего класса. Дочерний класс наследует свойства и методы родительского класса и может их расширять или переопределять.

**Пример из проекта:**

```javascript
// Родительский (базовый) класс
class ChargeHandler {
  #nextHandler = null;

  setNext(handler) {
    this.#nextHandler = handler;
  }

  handle(charge, service) {
    throw new Error("Метод должен быть переопределен");
  }
}

// Дочерний класс (наследуется от ChargeHandler)
class ValidationChargeHandler extends ChargeHandler {
  // Наследует метод setNext() из родительского класса

  // Переопределяет метод handle()
  handle(charge, service) {
    if (charge.quantity < 0) {
      throw new Error("Отрицательное количество");
    }
    return this._processNext(charge, service);
  }
}
```

**Ключевые моменты:**

- `extends` - ключевое слово для наследования
- Дочерний класс может использовать методы родителя
- Дочерний класс может переопределять методы родителя
- Избегаем дублирования кода

### Вопрос 5: "Объясните полиморфизм"

**Ответ:**
Полиморфизм - это способность объектов разных классов отвечать на один и тот же метод по-разному. "Один интерфейс, много реализаций".

**Пример из проекта:**

```javascript
// Все три класса имеют метод handle() с одинаковой сигнатурой,
// но реализуют его по-разному

class ValidationChargeHandler extends ChargeHandler {
  handle(charge, service) {
    // Реализация 1: проверка данных
    if (charge.quantity < 0) throw new Error("...");
    return this._processNext(charge, service);
  }
}

class DiscountChargeHandler extends ChargeHandler {
  handle(charge, service) {
    // Реализация 2: применение скидки
    const cost = service.calculateCost(charge.quantity);
    if (cost >= this.discountThreshold) {
      return cost - discount;
    }
    return this._processNext(charge, service);
  }
}

class StandardChargeHandler extends ChargeHandler {
  handle(charge, service) {
    // Реализация 3: стандартный расчет
    return service.calculateCost(charge.quantity);
  }
}

// Полиморфизм в действии:
let handler = new ValidationChargeHandler();
handler.handle(charge, service); // Вызовет реализацию 1

handler = new DiscountChargeHandler();
handler.handle(charge, service); // Вызовет реализацию 2

handler = new StandardChargeHandler();
handler.handle(charge, service); // Вызовет реализацию 3
```

**Преимущества:**

- Можно работать с разными объектами через единый интерфейс
- Легко добавлять новые типы обработчиков
- Код становится более гибким

### Вопрос 6: "Что такое this в JavaScript?"

**Ответ:**
`this` - это ключевое слово, которое ссылается на текущий объект, в контексте которого выполняется код.

**Примеры:**

1. **В методах класса:**

```javascript
class Service {
  constructor(tariff) {
    this.tariff = tariff; // this ссылается на создаваемый объект
  }

  calculateCost(quantity) {
    // this ссылается на объект, у которого вызван метод
    return this.tariff * quantity;
  }
}

const service = new Service(45.5);
service.calculateCost(10);
// Внутри метода: this = service
// this.tariff = service.tariff = 45.5
```

2. **В конструкторе:**

```javascript
class Street {
  constructor(streetCode, name) {
    // this ссылается на новый объект, который создается
    this.streetCode = streetCode;
    this.name = name;
  }
}

const street = new Street(1, "Ленина");
// Внутри constructor: this = новый объект {}
// this.streetCode = 1
// this.name = "Ленина"
// Возвращается объект { streetCode: 1, name: "Ленина" }
```

**Важно понимать:**

- `this` всегда зависит от контекста вызова
- В методах объекта `this` = объект, у которого вызван метод
- В конструкторе `this` = создаваемый объект

### Вопрос 7: "Что такое приватные поля (#)?"

**Ответ:**
Приватные поля - это поля класса, которые доступны только внутри самого класса. В JavaScript они обозначаются символом `#`.

**Пример:**

```javascript
class Database {
  #streets = new Map(); // Приватное поле

  addStreet(street) {
    // Внутри класса можно использовать
    this.#streets.set(street.streetCode, street);
  }

  getStreet(code) {
    // Внутри класса можно использовать
    return this.#streets.get(code);
  }
}

const db = new Database();

// ✅ Можно: через публичные методы
db.addStreet(new Street(1, "Ленина"));

// ❌ Нельзя: прямое обращение к приватному полю
db.#streets; // SyntaxError: Private field '#streets' must be declared
```

**Зачем нужны:**

- Инкапсуляция: скрытие внутренней реализации
- Защита данных от случайного изменения
- Обеспечение контроля доступа к данным

---

## Часть 7: Практические задания

### Задание 1: Создать новый класс

Создайте класс `Apartment` (Квартира) со следующими свойствами:

- `apartmentNumber` - номер квартиры
- `area` - площадь
- `residents` - количество жильцов

И методами:

- `getAreaPerPerson()` - возвращает площадь на одного человека

**Решение:**

```javascript
export class Apartment {
  constructor(apartmentNumber, area, residents) {
    this.apartmentNumber = apartmentNumber;
    this.area = area;
    this.residents = residents;
  }

  getAreaPerPerson() {
    if (this.residents === 0) {
      return 0;
    }
    return this.area / this.residents;
  }
}

// Использование
const apt = new Apartment("15", 45.5, 2);
console.log(apt.getAreaPerPerson()); // 22.75
```

### Задание 2: Реализовать наследование

Создайте класс `PremiumService` (Премиум услуга), который наследуется от `Service` и:

- Имеет дополнительное свойство `premiumFee` (премиум сбор)
- Переопределяет метод `calculateCost()`, добавляя премиум сбор к стоимости

**Решение:**

```javascript
export class PremiumService extends Service {
  constructor(serviceCode, name, tariff, premiumFee) {
    super(serviceCode, name, tariff); // Вызов конструктора родителя
    this.premiumFee = premiumFee;
  }

  calculateCost(quantity) {
    // Вызываем метод родителя и добавляем премиум сбор
    const baseCost = super.calculateCost(quantity);
    return baseCost + this.premiumFee;
  }
}

// Использование
const premium = new PremiumService(1, "Премиум вода", 45.5, 100);
const cost = premium.calculateCost(10);
// baseCost = 45.5 * 10 = 455
// cost = 455 + 100 = 555
```

### Задание 3: Добавить новый обработчик

Создайте класс `TaxChargeHandler`, который применяет налог 20% к стоимости.

**Решение:**

```javascript
export class TaxChargeHandler extends ChargeHandler {
  constructor(taxPercent) {
    super();
    this.taxPercent = taxPercent;
  }

  handle(charge, service) {
    const baseCost = service.calculateCost(charge.quantity);
    const tax = baseCost * (this.taxPercent / 100);
    return baseCost + tax; // Добавляем налог
  }
}

// Использование в цепочке
const taxHandler = new TaxChargeHandler(20);
validation.setNext(discount).setNext(taxHandler).setNext(standard);
```

---

## Заключение

Сегодня мы изучили все основные принципы объектно-ориентированного программирования на примере реального проекта:

1. **Инкапсуляция** - мы видели, как приватные поля защищают данные
2. **Наследование** - создавали иерархии классов с помощью `extends`
3. **Полиморфизм** - один интерфейс, разные реализации
4. **Абстракция** - выделение общих характеристик объектов

Этот проект демонстрирует не просто теоретические концепции, а реальное применение ООП в практике программирования. Каждый принцип используется осознанно, для решения конкретных задач.

### Чек-лист для экзамена

Перед экзаменом убедитесь, что вы можете:

- [ ] Объяснить, что такое класс и объект
- [ ] Показать, как создать класс и объект
- [ ] Объяснить роль конструктора
- [ ] Показать пример использования `this`
- [ ] Объяснить принцип инкапсуляции с примерами
- [ ] Показать использование приватных полей
- [ ] Объяснить принцип наследования
- [ ] Показать использование `extends` и `super`
- [ ] Объяснить принцип полиморфизма
- [ ] Показать переопределение методов
- [ ] Объяснить принцип абстракции
- [ ] Различить композицию и наследование
- [ ] Объяснить паттерны проектирования (Chain of Responsibility)
- [ ] Написать простой класс с нуля
- [ ] Реализовать наследование для нового класса
- [ ] Добавить новый метод в существующий класс

### Финальные рекомендации

1. **Запустите проект** - посмотрите, как он работает на практике
2. **Модифицируйте код** - добавьте свои классы, попробуйте изменить существующие
3. **Ответьте на вопросы** - попробуйте ответить на все типичные вопросы экзамена
4. **Выполните задания** - практика - лучший способ подготовки

Помните: понимание принципов ООП важнее заучивания определений. Если вы понимаете, ЗАЧЕМ используется каждый принцип, вы сможете объяснить его на любом примере.

**Удачи на экзамене! 🎓**

Если у вас остались вопросы - задавайте их прямо сейчас, и мы разберем их вместе.
